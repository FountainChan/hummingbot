# Hummingbot 控制器系统详解

## 控制器概述

控制器（Controllers）是独立的交易算法模块，负责：
1. **分析市场数据**（技术指标、K线等）
2. **生成交易信号**（买、卖、持仓）
3. **创建和管理执行器**（下单执行）
4. **监控位置和盈亏**（性能跟踪）

控制器是 Hummingbot v2 中的核心创新，允许在一个策略中运行多个独立的交易算法。

## 控制器架构

### 基类继承关系

```
RunnableBase
    ↓
ControllerBase
    ↓
    ├─ DirectionalTradingControllerBase
    │   ├─ BollingerV1Controller
    │   ├─ BollingerV2Controller
    │   ├─ SuperTrendV1Controller
    │   ├─ MacdBbV1Controller
    │   └─ RSIDirectionalController
    │
    └─ MarketMakingControllerBase
        ├─ PMMSimpleController
        ├─ PMMDynamicController
        └─ DManMakerV2Controller
```

### 基类：ControllerBase

```python
from hummingbot.strategy_v2.controllers.controller_base import ControllerBase, ControllerConfigBase


class ControllerBase(RunnableBase):
    """所有控制器的基类"""
    
    def __init__(self, config: ControllerConfigBase):
        super().__init__(config.update_interval)
        self.config = config
        self.id = config.controller_name
    
    async def control_task(self) -> None:
        """
        控制任务：
        1. 获取并分析市场数据
        2. 生成交易信号
        3. 创建执行器
        """
        pass
    
    def get_custom_info(self) -> dict:
        """返回自定义信息（用于报告）"""
        return {}
    
    def get_performance_report(self):
        """获取性能报告"""
        pass
```

## 内置控制器详解

### 1. BollingerV1Controller（布林带控制器）

**原理**：基于布林带突破的方向性交易

**配置**：

```python
from controllers.directional_trading.bollinger_v1 import BollingerV1ControllerConfig


config = BollingerV1ControllerConfig(
    controller_name="bollinger_v1",
    connector_name="binance",
    trading_pair="BTC-USDT",
    candles_connector="binance",
    candles_trading_pair="BTC-USDT",
    interval="1h",                  # 1 小时蜡烛
    bb_length=20,                   # 布林带周期
    bb_std=2.0,                     # 标准差倍数
    bb_long_threshold=0.0,          # 做多阈值（0-1）
    bb_short_threshold=1.0,         # 做空阈值（0-1）
)
```

**指标计算**：

```
布林带 = 中线 ± 标准差倍数 × 标准差
中线 = 20 日简单移动平均
上轨 = 中线 + 2 × 标准差
下轨 = 中线 - 2 × 标准差

BB 值 = (收盘价 - 下轨) / (上轨 - 下轨)
```

**交易信号**：
- **做多**：BB 值 < 0.0（价格跌破下轨）
- **做空**：BB 值 > 1.0（价格突破上轨）
- **平仓**：与相反信号相反

**适用场景**：
- 高波动性市场
- 均值回归交易
- 非趋势市场

### 2. BollingerV2Controller（改进版布林带）

**改进**：
- 支持动态周期调整
- 更好的信号过滤
- 改进的止损机制

**配置**：

```python
from controllers.directional_trading.bollinger_v2 import BollingerV2ControllerConfig


config = BollingerV2ControllerConfig(
    controller_name="bollinger_v2",
    # ... 基础配置同 V1 ...
    bb_length=20,
    bb_std=2.0,
    bb_long_threshold=0.2,    # 更灵敏的阈值
    bb_short_threshold=0.8,
)
```

### 3. SuperTrendV1Controller（超级趋势）

**原理**：基于 ATR（真实波幅）和移动平均的趋势跟踪

**配置**：

```python
from controllers.directional_trading.supertrend_v1 import SuperTrendV1ControllerConfig


config = SuperTrendV1ControllerConfig(
    controller_name="supertrend_v1",
    connector_name="binance",
    trading_pair="BTC-USDT",
    candles_connector="binance",
    candles_trading_pair="BTC-USDT",
    interval="1h",
    supertrend_period=10,       # ATR 周期
    supertrend_multiplier=3.0,  # ATR 倍数
)
```

**指标计算**：

```
ATR = 平均真实波幅（N 天内高低价差的平均）
上带 = HL2 + 倍数 × ATR
下带 = HL2 - 倍数 × ATR
其中 HL2 = (最高价 + 最低价) / 2
```

**交易信号**：
- **做多**：价格上穿下带
- **做空**：价格下穿上带

**适用场景**：
- 强趋势市场
- 自适应止损
- 顺势交易

### 4. MacdBbV1Controller（MACD + 布林带）

**原理**：组合使用 MACD 和布林带确认信号

**配置**：

```python
config = MacdBbV1ControllerConfig(
    controller_name="macd_bb_v1",
    # ... 基础配置 ...
    macd_fast=12,               # MACD 快线周期
    macd_slow=26,               # MACD 慢线周期
    macd_signal=9,              # MACD 信号线周期
    bb_length=20,
    bb_std=2.0,
)
```

**交易逻辑**：
```
条件 1: MACD 金叉（快线 > 慢线）或死叉（快线 < 慢线）
条件 2: 价格在布林带相应位置

当两个条件同时满足时生成强信号
```

### 5. DManV3Controller（动态管理）

**原理**：基于动态市场条件的自适应交易

**配置**：

```python
config = DManV3ControllerConfig(
    controller_name="dman_v3",
    # ... 基础配置 ...
    trade_type="short",         # "short" 或 "long"
    candles_length=100,         # K线历史长度
)
```

**特点**：
- 自适应的市场环境检测
- 动态调整风险参数
- 优化的持仓管理

### 6. PMM SimpleController（简单做市）

**原理**：提供两边流动性的简单做市

**配置**：

```python
from controllers.market_making.pmm_simple import PMMSimpleControllerConfig


config = PMMSimpleControllerConfig(
    controller_name="pmm_simple",
    connector_name="binance",
    trading_pair="BTC-USDT",
    bid_spread=0.001,           # 买方差价（0.1%）
    ask_spread=0.001,           # 卖方差价（0.1%）
    order_amount=0.1,           # 单笔订单大小
    order_refresh_time=30,      # 订单刷新时间（秒）
)
```

**工作原理**：

```
中价: 30000

订单放置:
买: 30000 - 30000 × 0.001 = 29997 (买方流动性)
卖: 30000 + 30000 × 0.001 = 30003 (卖方流动性)

当买入成交时，放置新的卖单
当卖出成交时，放置新的买单
```

**参数**：
- `bid_spread`：买价较中价的下降幅度
- `ask_spread`：卖价较中价的上升幅度
- `order_amount`：每个订单的大小
- `order_refresh_time`：多久更新一次订单

### 7. PMM DynamicController（动态做市）

**原理**：根据市场条件动态调整差价

**特点**：
- 动态调整差价
- 库存感知
- 优化 P&L
- 风险自适应

**配置**：

```python
config = PMMDynamicControllerConfig(
    controller_name="pmm_dynamic",
    connector_name="binance",
    trading_pair="BTC-USDT",
    bid_spread=0.001,
    ask_spread=0.001,
    order_amount=0.1,
    # 动态参数
    order_optimization_enabled=True,
    volatility_scaling_enabled=True,
)
```

## 开发新控制器

### 第一步：定义配置类

```python
from pydantic import Field, field_validator
from hummingbot.data_feed.candles_feed.data_types import CandlesConfig
from hummingbot.strategy_v2.controllers.directional_trading_controller_base import (
    DirectionalTradingControllerConfigBase,
)


class MyNewControllerConfig(DirectionalTradingControllerConfigBase):
    """自定义控制器配置"""
    
    controller_name: str = "my_new_controller"
    candles_config: List[CandlesConfig] = []
    
    # 交易参数
    connector_name: str = Field(default="binance")
    trading_pair: str = Field(default="BTC-USDT")
    
    # 算法参数
    param1: int = Field(default=10)
    param2: float = Field(default=0.5)
    
    @field_validator("candles_connector", mode="before")
    @classmethod
    def set_candles_connector(cls, v, validation_info):
        if v is None or v == "":
            return validation_info.data.get("connector_name")
        return v
```

### 第二步：实现控制器逻辑

```python
from hummingbot.strategy_v2.controllers.directional_trading_controller_base import (
    DirectionalTradingControllerBase,
)
from hummingbot.strategy_v2.models.executor_actions import CreateExecutorAction
from hummingbot.core.event.events import TradeType
import pandas as pd


class MyNewController(DirectionalTradingControllerBase):
    """自定义交易控制器"""
    
    def __init__(self, config: MyNewControllerConfig):
        super().__init__(config)
        self.config = config
        self.indicator_value = None
    
    async def control_task(self) -> None:
        """
        控制任务：
        1. 获取 K 线数据
        2. 计算指标
        3. 生成信号
        4. 创建执行器
        """
        # 获取蜡烛线数据
        candles = self.get_candles()
        
        # 数据验证
        if len(candles) < self.config.param1:
            self.logger().warning("K线数据不足")
            return
        
        # 计算指标
        self.calculate_indicators(candles)
        
        # 生成信号
        signal = self.generate_signal(candles)
        
        # 如果有信号，创建执行器
        if signal is not None:
            await self.create_executor_with_signal(signal)
    
    def calculate_indicators(self, candles: pd.DataFrame):
        """计算技术指标"""
        closes = candles["close"].values
        highs = candles["high"].values
        lows = candles["low"].values
        
        # 计算 MA
        ma = pd.Series(closes).rolling(self.config.param1).mean()
        self.indicator_value = closes[-1] - ma.iloc[-1]
    
    def generate_signal(self, candles: pd.DataFrame) -> Optional[TradeType]:
        """
        生成交易信号
        返回: TradeType.BUY, TradeType.SELL 或 None
        """
        if self.indicator_value > self.config.param2:
            return TradeType.BUY
        elif self.indicator_value < -self.config.param2:
            return TradeType.SELL
        return None
    
    async def create_executor_with_signal(self, side: TradeType):
        """根据信号创建执行器"""
        from hummingbot.strategy_v2.executors.order_executor.data_types import OrderExecutorConfig
        
        executor_config = OrderExecutorConfig(
            id=f"{self.config.controller_name}_{side.name}_{int(self.timestamp)}",
            connector_name=self.config.connector_name,
            trading_pair=self.config.trading_pair,
            execute_side=side,
            leverage=Decimal("1"),
            amount=Decimal("1"),
            order_optimization_enabled=True,
        )
        
        action = CreateExecutorAction(
            controller_id=self.config.controller_name,
            executor_config=executor_config,
        )
        
        return action
    
    def get_candles(self) -> pd.DataFrame:
        """获取蜡烛线数据"""
        # 从 K 线源获取数据
        return self.fetch_candles(
            self.config.candles_connector,
            self.config.candles_trading_pair,
            self.config.interval
        )
    
    def get_custom_info(self) -> dict:
        """返回自定义信息用于日志记录"""
        return {
            "indicator_value": float(self.indicator_value) if self.indicator_value else 0,
            "latest_price": self.get_latest_price(),
        }
```

### 第三步：在策略中使用

```python
from hummingbot.strategy.strategy_v2_base import StrategyV2Base


class MyStrategy(StrategyV2Base):
    
    def __init__(self, connectors, config):
        super().__init__(connectors, config)
        
        # 初始化控制器
        controller_config = MyNewControllerConfig(
            connector_name="binance",
            trading_pair="BTC-USDT",
            param1=20,
            param2=100,
        )
        
        self.controllers["my_controller"] = MyNewController(controller_config)
```

## K 线数据源配置

所有控制器都需要 K 线（蜡烛线）数据：

```python
from hummingbot.data_feed.candles_feed.data_types import CandlesConfig


candles_config = CandlesConfig(
    connector="binance",           # 数据源交易所
    trading_pair="BTC-USDT",      # 交易对
    interval="1h",                 # 时间间隔（1m, 5m, 1h, 1d 等）
    max_records=1000,              # 保存的最大 K 线数量
)
```

## 控制器性能指标

### 关键指标

```python
report = controller.get_performance_report()

# 利润指标
report.total_pnl           # 总利润
report.total_pnl_quote     # 按基准交易对计算的总利润
report.total_pnl_pct       # 利润百分比

# 交易指标
report.trade_count         # 交易次数
report.wins                # 盈利交易数
report.losses              # 亏损交易数

# 风险指标
report.max_drawdown        # 最大回撤
report.sharpe_ratio        # 夏普比率
```

## 多控制器策略示例

```python
class MultiControllerStrategy(StrategyV2Base):
    
    def __init__(self, connectors, config):
        super().__init__(connectors, config)
        
        # 趋势跟踪控制器
        trend_controller = SuperTrendV1Controller(
            SuperTrendV1ControllerConfig(
                trading_pair="BTC-USDT",
            )
        )
        
        # 做市控制器
        mm_controller = PMMSimpleController(
            PMMSimpleControllerConfig(
                trading_pair="ETH-USDT",
            )
        )
        
        self.controllers["trend"] = trend_controller
        self.controllers["mm"] = mm_controller
```

## 常见问题

**Q: 控制器和执行器的区别？**
A: 
- 控制器：分析市场数据，生成信号
- 执行器：执行控制器的信号，管理订单生命周期

**Q: 可以同时运行多个控制器吗？**
A: 可以，这是 Hummingbot v2 的设计初衷，每个控制器独立运行。

**Q: 如何调整控制器参数？**
A: 通过配置文件或 CLI 提示修改参数，然后重启策略。

## 下一步

- 查看[执行器系统](../执行器/执行器系统.md)
- 阅读[策略开发指南](../策略开发/新策略开发指南.md)  
- 浏览 `controllers/` 目录中的实现源代码
